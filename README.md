# java设计模式
### 一. 仓库介绍

本仓库通过图形和代码结合的方式来解析设计模式；

在设计模式中，每种模式都有自己特定的对象结构图，为了展示对象间的交互细节，使用多种UML图示多方位解析该设计模式是如何运行的。

为了便于大家的理解，每一种设计模式都会附加介绍。

在学习完设计模式之后，我们需要达到3个目标：

1. 能在白纸上画出所有的模式结构；
2. 能用代码实现；如果模式的代码都没有实现过，是用不出来的；即所谓，看得懂，不会用；
3. 灵活应用到实际的工作项目中；

### 二. 设计模式概览(23种)

##### [创建型模式]

创建型模式，就是创建对象的模式，抽象了实例化的过程。 
它帮助一个系统独立于如何创建、组合和表示它的那些对象。 
关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。

| 编号 | 名称(中)                                                     | 名称(英)                                                     | 简介                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | [工厂方法模式](https://github.com/a494456818/design-patterns-java/tree/master/1-Creational-Patterns/01-Factory-Method-Pattern) | [Factory Method Pattern](https://github.com/a494456818/design-patterns-java/tree/master/1-Creational-Patterns/01-Factory-Method-Pattern) | 定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。 |
| 2    | 抽象工厂模式                                                 | Abstract Factory Pattern                                     | 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 |
| 3    | 建造者模式                                                   | Builder Pattern                                              | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 |
| 4    | 原型模式                                                     | Prototype Pattern                                            | 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 |
| 5    | 单例模式                                                     | Singleton Pattern                                            | 保证一个类仅有一个实例，并提供一个访问它的全局访问点。       |

##### [结构型模式]

结构型模式是为解决怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能。

| 编号 | 名称(中)          | 名称(英)          | 简介                                                         |
| ---- | ----------------- | ----------------- | ------------------------------------------------------------ |
| 1    | 适配器模式        | Adapter Pattern   | 将一个类的接口转换成客户希望的另外一个接口。                 |
| 2    | 桥梁模式/桥接模式 | Bridge Pattern    | 将抽象部分与它的实现部分分离，使它们都可以独立的变化。       |
| 3    | 组合模式          | Composite Pattern | 将对象组合成树形结构以表示“部分-整体”的层次结构。            |
| 4    | 装饰模式          | Decorator Pattern | 动态地给一个对象添加一些额外的职责。                         |
| 5    | 门面模式/外观模式 | Facade Pattern    | 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 |
| 6    | 享元模式          | Flyweight Pattern | 运用共享技术有效地支持大量细粒度的对象。                     |
| 7    | 代理模式          | Proxy pattern     | 为其它对象提供一种代理以控制对这个对象的访问。               |

##### [行为型模式]

行为型模式是对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用，通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。

| 编号 | 名称(中)     | 名称(英)                        | 简介                                                         |
| ---- | ------------ | ------------------------------- | ------------------------------------------------------------ |
| 1    | 责任链模式   | Chain of Responsibility Pattern | 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 |
| 2    | 命令模式     | Command Pattern                 | 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 |
| 3    | 解释器模式   | Interpreter Pattern             | 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语句中的句子。 |
| 4    | 迭代器模式   | Iterator Pattern                | 提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。 |
| 5    | 中介者模式   | Mediator Pattern                | 用一个中介对象来封装一系列的对象交互。                       |
| 6    | 备忘录模式   | Memento Pattern                 | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 |
| 7    | 观察者模式   | Observer Pattern                | 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 |
| 8    | 状态模式     | State Pattern                   | 允许一个对象在其内部状态改变时改变它的行为。                 |
| 9    | 策略模式     | Strategy Pattern                | 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 |
| 10   | 模板方法模式 | Template Method Pattern         | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。       |
| 11   | 访问者模式   | Visitor Pattern                 | 表示一个作用于某对象结构中的各元素的操作。                   |

### 三. 设计模式六大原则

**1、开闭原则（Open Close Principle）**

开闭原则就是说**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

**3、依赖倒转原则（Dependence Inversion Principle）**

这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

**5、迪米特法则（最少知道原则）（Demeter Principle）**

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

原则是尽量使用合成/聚合的方式，而不是使用继承。